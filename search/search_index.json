{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> <code>useq-schema</code> is an implementation agnostic schema for describing a sequence of events during a multi-dimensional imaging acquisition. </p> <p>The goal of this repo is to provide a specification (and some python utilities) for generating event objects that can be consumed by microscope acquisition engines. A hope is that this will encourage inter-operability between various efforts to drive automated image acquisition.</p> <p>The schema tries to remain agnostic to the specific acquisition engine (though it was designed based on the capabilities Micro-Manager). We welcome feedback from interested parties regarding limitations and/or potential extensions to the schema! Similarly, while the \"ideal\" schema will support arbitrary dimensions (i.e. more than the conventional position, time, channel, z, ...), it also hard to avoid hard-coding some assumptions about dimensionality in certain places.  Any and all feedback (even minor stuff, such as parameter naming, etc...) is welcome! Please open an issue.</p>"},{"location":"#core-schema","title":"Core Schema","text":""},{"location":"#mdaevent","title":"<code>MDAEvent</code>","text":"<p>The primary \"event\" object is <code>useq.MDAEvent</code>.  This describes a single event that a microscope should perform, including preparation of the hardware, and execution of the event (such as an image acquisition).</p> <ul> <li>For micro-manager, this   object is most similar (though not identical) to the events generated by   <code>generate-acq-sequence</code>   in the clojure acquisition engine that drives Micro-Managers multi-dimensional   acquisitions.</li> <li>For Pycro-manager, this   object is similar to an individual acquisition event   <code>dict</code>   generated by   <code>multi_d_acquisition_events</code>,   (and, <code>MDAEvent</code> provides a <code>to_pycromanager</code> method   that returns a single dict following the pycro-manager event spec)</li> <li>your object here?...</li> </ul>"},{"location":"#mdasequence","title":"<code>MDASequence</code>","text":"<p><code>useq.MDASequence</code> represents a sequence of events \u2013 as might be generated by the multidimensional acquisition GUI in most microscope software. The Python <code>MDASequence</code> object is itself iterable, and yields <code>useq.MDAEvent</code> objects.</p> <ul> <li>For micro-manager, this   object is most similar to   <code>org.micromanager.acquisition.SequenceSettings</code>,   (generated by clicking the <code>Acquire!</code> button in the Multi-D Acquisition   GUI)</li> <li>For Pycro-manager, this   object is similar to the   <code>multi_d_acquisition_events</code>   convenience function, (and the Python <code>MDASequence</code> object provides a   <code>to_pycromanager</code> method   that returns a list of pycro-manager events)</li> <li>your object here?...</li> </ul>"},{"location":"#executing-an-mdasequence","title":"Executing an MDASequence","text":"<p>This library is just a schema, and does not provide any built-in functionality for executing an <code>MDASequence</code>.  However, <code>pymmcore-plus</code> implements an acquisition engine that can execute an <code>MDASequence</code> object with micro-manager (via the <code>pymmcore</code> python wrapper around the C++ MMCore).  See the <code>pymmcore_plus.CMMCorePlus.run_mda</code> method for more. <code>napari-micromanager</code> also creates a <code>useq.MDASequence</code> object from user input and passes it to <code>pymmcore-plus</code> for execution.</p> <p>hi! </p> <p>Have you implemented an acquisition engine that can execute a <code>useq.MDASequence</code>? Let us know so we can add it here!</p>"},{"location":"#serialization-and-deserialization","title":"Serialization and Deserialization","text":"<p><code>MDASequence</code> and <code>MDAEvent</code> objects are designed to be serialized and deserialized, allowing you to define an entire multi-dimensional acquisition in human-readable YAML (or JSON) file, and then load that file into your acquisition engine.</p> <p>For example, the following file defines an experiment with:</p> <ul> <li>3 channels (<code>DAPI</code>, <code>FITC</code>, and <code>Cy5</code>), specifying exposure times for each channel</li> <li>a two-phase time-lapse: 3 frames in the first phase, followed by a frame every 10 seconds for 40 minutes</li> <li>a Z-stack at each timepoint, with a range of 4 microns and a step size of 0.5 micron</li> <li>two stage positions, specifying a unique Z-stack for the second position</li> </ul> <p>Example</p> YAMLJSON my_experiment.yaml<pre><code>axis_order: tpcz\nchannels:\n- config: Cy5\nexposure: 50.0\n- config: FITC\nexposure: 100.0\n- config: DAPI\nacquire_every: 3\ndo_stack: false\ntime_plan:\nphases:\n- interval: 0:00:03\nloops: 3\n- duration: 0:40:00\ninterval: 0:00:10\nz_plan:\nrange: 4.0\nstep: 0.5\nstage_positions:\n- x: 10.0\ny: 20.0\n- name: Cell 1\nx: 10.0\ny: 20.0\nz: 50.0\nz_plan:\nabove: 10.0\nbelow: 0.0\nstep: 1.0\nmetadata:\nsome info: about my experiment\n</code></pre> my_experiment.json<pre><code>{\n\"axis_order\": \"tpcz\",\n\"channels\": [\n{\n\"config\": \"Cy5\",\n\"exposure\": 50.0\n},\n{\n\"config\": \"FITC\",\n\"exposure\": 100.0\n},\n{\n\"config\": \"DAPI\",\n\"acquire_every\": 3,\n\"do_stack\": false\n}\n],\n\"time_plan\": {\n\"phases\": [\n{\n\"interval\": \"0:00:03\",\n\"loops\": 3\n},\n{\n\"duration\": \"0:40:00\",\n\"interval\": \"0:00:10\"\n}\n]\n},\n\"z_plan\": {\n\"range\": 4.0,\n\"step\": 0.5\n},\n\"stage_positions\": [\n{\n\"x\": 10.0,\n\"y\": 20.0\n},\n{\n\"name\": \"Cell 1\",\n\"x\": 10.0,\n\"y\": 20.0,\n\"z\": 50.0,\n\"z_plan\": {\n\"above\": 10.0,\n\"below\": 0.0,\n\"step\": 1.0\n}\n}\n],\n\"metadata\": {\n\"some info\": \"about my experiment\"\n}\n}\n</code></pre>"},{"location":"api/","title":"API","text":"<p>In addition to declaring a schema (which is intended to be language agnostic), <code>useq-schema</code> offers a python API for working with <code>MDASequence</code> and <code>MDAEvent</code> objects.</p>"},{"location":"api/#useq.MDASequence","title":"<code>MDASequence</code>","text":"<p>A sequence of MDA (Multi-Dimensional Acquisition) events.</p> <p>This is the core object in the <code>useq</code> library, and is used define a sequence of events to be run on a microscope. It object may be constructed manually, or from file (e.g. json or yaml).</p> <p>The object itself acts as an iterator for <code>useq.MDAEvent</code> objects:</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>dict</code> <p>A dictionary of user metadata to be stored with the sequence.</p> <code>axis_order</code> <code>str</code> <p>The order of the axes in the sequence. Must be a permutation of <code>\"tpcz\"</code>. The default is <code>\"tpcz\"</code>.</p> <code>stage_positions</code> <code>tuple[Position, ...]</code> <p>The stage positions to visit. (each with <code>x</code>, <code>y</code>, <code>z</code>, <code>name</code>, and <code>z_plan</code>, all of which are optional).</p> <code>channels</code> <code>tuple[Channel, ...]</code> <p>The channels to acquire. see <code>Channel</code>.</p> <code>time_plan</code> <code>MultiPhaseTimePlan | TIntervalDuration | TIntervalLoops | TDurationLoops | NoT</code> <p>The time plan to follow. One of <code>TIntervalDuration</code>, <code>TIntervalLoops</code>, <code>TDurationLoops</code>, <code>MultiPhaseTimePlan</code>, or <code>NoT</code></p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | NoZ</code> <p>The z plan to follow. One of <code>ZTopBottom</code>, <code>ZRangeAround</code>, <code>ZAboveBelow</code>, <code>ZRelativePositions</code>, <code>ZAbsolutePositions</code>, or <code>NoZ</code>.</p> <code>uid</code> <code>UUID</code> <p>A read-only unique identifier (uuid version 4) for the sequence. This will be generated, do not set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from useq import MDASequence, Position, Channel, TIntervalDuration\n&gt;&gt;&gt; seq = MDASequence(\n...     time_plan={\"interval\": 0.1, \"loops\": 2},\n...     stage_positions=[(1, 1, 1)],\n...     z_plan={\"range\": 3, \"step\": 1},\n...     channels=[{\"config\": \"DAPI\", \"exposure\": 1}]\n... )\n&gt;&gt;&gt; print(seq)\nMulti-Dimensional Acquisition \u25b6 nt: 2, np: 1, nc: 1, nz: 4\n</code></pre> <pre><code>&gt;&gt;&gt; for event in seq:\n...     print(event)\n</code></pre> <pre><code>&gt;&gt;&gt; print(seq.yaml())\nchannels:\n- config: DAPI\n  exposure: 1.0\nstage_positions:\n- x: 1.0\n  y: 1.0\n  z: 1.0\ntime_plan:\n  interval: '0:00:00.100000'\n  loops: 2\nz_plan:\n  range: 3.0\n  step: 1.0\n</code></pre>"},{"location":"api/#useq._mda_sequence.MDASequence.shape","title":"<code>shape: Tuple[int, ...]</code>  <code>property</code>","text":"<p>Return the shape of this sequence.</p> <p>Note</p> <p>This doesn't account for jagged arrays, like skipped Z or channel frames.</p>"},{"location":"api/#useq._mda_sequence.MDASequence.sizes","title":"<code>sizes: Dict[str, int]</code>  <code>property</code>","text":"<p>Mapping of axis to size of that axis.</p>"},{"location":"api/#useq._mda_sequence.MDASequence.used_axes","title":"<code>used_axes: str</code>  <code>property</code>","text":"<p>Single letter string of axes used in this sequence, e.g. <code>ztc</code>.</p>"},{"location":"api/#useq._mda_sequence.MDASequence.replace","title":"<code>replace(metadata: Dict[str, Any] = Undefined, axis_order: str = Undefined, stage_positions: Tuple[Position, ...] = Undefined, channels: Tuple[Channel, ...] = Undefined, time_plan: AnyTimePlan = Undefined, z_plan: AnyZPlan = Undefined) -&gt; MDASequence</code>","text":"<p>Return a new <code>MDAsequence</code> replacing specified kwargs with new values.</p> <p>MDASequences are immutable, so this method is useful for creating a new sequence with only a few fields changed.  The uid of the new sequence will be different from the original</p>"},{"location":"api/#useq._mda_sequence.MDASequence.iter_axis","title":"<code>iter_axis(axis: str) -&gt; Iterator[Position | Channel | float]</code>","text":"<p>Iterate over the events of a given axis.</p>"},{"location":"api/#useq._mda_sequence.MDASequence.iter_events","title":"<code>iter_events() -&gt; Iterator[MDAEvent]</code>","text":"<p>Iterate over all events in the MDA sequence.</p> <p>See source of useq._mda_sequence.iter_sequence for details on how events are constructed and yielded.</p> <p>Yields:</p> Type Description <code>MDAEvent</code> <p>Each event in the MDA sequence.</p>"},{"location":"api/#useq._mda_sequence.MDASequence.to_pycromanager","title":"<code>to_pycromanager() -&gt; list[dict]</code>","text":"<p>Convenience to convert this sequence to a list of pycro-manager events.</p> <p>See: https://pycro-manager.readthedocs.io/en/latest/apis.html</p>"},{"location":"api/#useq._mda_sequence.MDASequence.__eq__","title":"<code>__eq__(other: Any) -&gt; bool</code>","text":"<p>Return <code>True</code> if two <code>MDASequences</code> are equal (uid is excluded).</p>"},{"location":"api/#useq._mda_sequence.MDASequence.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return the number of events in this sequence.</p>"},{"location":"api/#useq._mda_sequence.MDASequence.__iter__","title":"<code>__iter__() -&gt; Iterator[MDAEvent]</code>","text":"<p>Same as <code>iter_events</code>. Supports <code>for event in sequence: ...</code> syntax.</p>"},{"location":"api/#useq._mda_sequence.iter_sequence","title":"<code>iter_sequence(sequence: MDASequence) -&gt; Iterator[MDAEvent]</code>","text":"<p>Iterate over all events in the MDA sequence.</p> <p>Note</p> <p>This method will usually be used via <code>useq.MDASequence.iter_events</code>, or by simply iterating over the sequence.</p> <p>This does the job of iterating over all the frames in the MDA sequence, handling the logic of merging all z plans in channels and stage positions defined in the plans for each axis.</p> <p>The is the most \"logic heavy\" part of <code>useq-schema</code> (the rest of which is almost entirely declarative).  This iterator is useful for consuming <code>MDASequence</code> objects in a python runtime, but it isn't considered a \"core\" part of the schema.</p> <p>Yields:</p> Type Description <code>MDAEvent</code> <p>Each event in the MDA sequence.</p> Source code in <code>useq/_mda_sequence.py</code> <pre><code>def iter_sequence(sequence: MDASequence) -&gt; Iterator[MDAEvent]:\n\"\"\"Iterate over all events in the MDA sequence.\n\n    !!! note\n\n        This method will usually be used via [`useq.MDASequence.iter_events`][], or by\n        simply iterating over the sequence.\n\n    This does the job of iterating over all the frames in the MDA sequence,\n    handling the logic of merging all z plans in channels and stage positions\n    defined in the plans for each axis.\n\n    The is the most \"logic heavy\" part of `useq-schema` (the rest of which is\n    almost entirely declarative).  This iterator is useful for consuming `MDASequence`\n    objects in a python runtime, but it isn't considered a \"core\" part of the schema.\n\n    Yields\n    ------\n    MDAEvent\n        Each event in the MDA sequence.\n    \"\"\"\n    order = sequence.used_axes\n\n    event_iterator = (enumerate(sequence.iter_axis(ax)) for ax in order)\n    for global_index, item in enumerate(product(*event_iterator)):\n        if not item:  # the case with no events\n            continue\n\n        _ev = dict(zip(order, item))\n        index = {k: _ev[k][0] for k in INDICES if k in _ev}\n\n        position: Optional[Position] = _ev[POSITION][1] if POSITION in _ev else None\n        channel: Optional[Channel] = _ev[CHANNEL][1] if CHANNEL in _ev else None\n        time: Optional[int] = _ev[TIME][1] if TIME in _ev else None\n\n        # skip channels\n        if channel and TIME in index and index[TIME] % channel.acquire_every:\n            continue\n\n        try:\n            z_pos = (\n                sequence._combine_z(_ev[Z][1], index[Z], channel, position)\n                if Z in _ev\n                else position.z\n                if position\n                else None\n            )\n        except sequence._SkipFrame:\n            continue\n\n        _channel = (\n            {\"config\": channel.config, \"group\": channel.group} if channel else None\n        )\n        yield MDAEvent(\n            index=index,\n            min_start_time=time,\n            pos_name=getattr(position, \"name\", None),\n            x_pos=getattr(position, \"x\", None),\n            y_pos=getattr(position, \"y\", None),\n            z_pos=z_pos,\n            exposure=getattr(channel, \"exposure\", None),\n            channel=_channel,\n            sequence=sequence,\n            global_index=global_index,\n        )\n</code></pre>"},{"location":"schema/axes/","title":"Axes","text":"<p>The following objects may be used to describe iteration over specific types of dimensions.</p>"},{"location":"schema/axes/#time-plans","title":"Time Plans","text":"<p>Ways to describe a temporal acquisition sequence.</p>"},{"location":"schema/axes/#useq.TIntervalDuration","title":"<code>TIntervalDuration</code>","text":"<p>Define temporal sequence using interval and duration.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames.</p> <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.TIntervalLoops","title":"<code>TIntervalLoops</code>","text":"<p>Define temporal sequence using interval and number of loops.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames.</p> <code>loops</code> <code>PositiveInt</code> <p>Number of frames.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>False</code>.</p>"},{"location":"schema/axes/#useq.TDurationLoops","title":"<code>TDurationLoops</code>","text":"<p>Define temporal sequence using duration and number of loops.</p> <p>Attributes:</p> Name Type Description <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>loops</code> <code>PositiveInt</code> <p>Number of frames.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>False</code>.</p>"},{"location":"schema/axes/#useq.TIntervalDuration","title":"<code>TIntervalDuration</code>","text":"<p>Define temporal sequence using interval and duration.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames.</p> <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.MultiPhaseTimePlan","title":"<code>MultiPhaseTimePlan</code>","text":"<p>Time sequence composed of multiple phases.</p> <p>Attributes:</p> Name Type Description <code>phases</code> <code>Sequence[TIntervalDuration | TIntervalLoops | TDurationLoops | NoT]</code> <p>Sequence of time plans.</p>"},{"location":"schema/axes/#useq.NoT","title":"<code>NoT</code>","text":"<p>Don't acquire a time sequence.</p>"},{"location":"schema/axes/#z-plans","title":"Z Plans","text":"<p>Ways to describe a z-stack acquisition sequence.</p>"},{"location":"schema/axes/#useq.ZTopBottom","title":"<code>ZTopBottom</code>","text":"<p>Define Z using absolute top &amp; bottom positions.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top position.</p> <code>bottom</code> <code>float</code> <p>Bottom position.</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZAboveBelow","title":"<code>ZAboveBelow</code>","text":"<p>Define Z as asymmetric range above and below some reference position.</p> <p>Attributes:</p> Name Type Description <code>above</code> <code>float</code> <p>Range above reference position in microns.</p> <code>below</code> <code>float</code> <p>Range below reference position in microns.</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZAbsolutePositions","title":"<code>ZAbsolutePositions</code>","text":"<p>Define Z as a list of absolute positions.</p> <p>Attributes:</p> Name Type Description <code>relative</code> <code>list[float]</code> <p>List of relative z positions.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code> (the default), visits points in the order provided, otherwise in reverse.</p>"},{"location":"schema/axes/#useq.ZRangeAround","title":"<code>ZRangeAround</code>","text":"<p>Define Z as a symmetric range around some reference position.</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range in microns.</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZRelativePositions","title":"<code>ZRelativePositions</code>","text":"<p>Define Z as a list of positions relative to some reference.</p> <p>Attributes:</p> Name Type Description <code>relative</code> <code>list[float]</code> <p>List of relative z positions.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code> (the default), visits points in the order provided, otherwise in reverse.</p>"},{"location":"schema/axes/#useq.NoZ","title":"<code>NoZ</code>","text":"<p>Don't acquire Z.</p>"},{"location":"schema/axes/#useq.Position","title":"<code>Position</code>","text":"<p>Define a position in 3D space.</p> <p>Any of the attributes can be <code>None</code> to indicate that the position is not defined. This is useful for defining a position relative to the current position.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float | None</code> <p>X position in microns.</p> <code>y</code> <code>float | None</code> <p>Y position in microns.</p> <code>z</code> <code>float | None</code> <p>Z position in microns.</p> <code>name</code> <code>str | None</code> <p>Optional name for the position.</p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | NoZ | None</code> <p>Z plan to execute at this position specifically. By default, <code>NoZ</code>.</p>"},{"location":"schema/axes/#useq.Channel","title":"<code>Channel</code>","text":"<p>Define an acquisition channel.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>Name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).</p> <code>group</code> <code>str</code> <p>Optional name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p> <code>exposure</code> <code>PositiveFloat | None</code> <p>Exposure time in seconds. If not provided, implies use current exposure time. By default, <code>None</code>.</p> <code>do_stack</code> <code>bool</code> <p>If <code>True</code>, instructs engine to include this channel in any Z stacks being acquired. By default, <code>True</code>.</p> <code>z_offset</code> <code>float</code> <p>Relative Z offset from current position, in microns. By default, <code>0</code>.</p> <code>acquire_every</code> <code>PositiveInt</code> <p>Acquire every Nth frame (if acquiring a time series). By default, <code>1</code>.</p> <code>camera</code> <code>str | None</code> <p>Name of the camera to use for this channel. If not provided, implies use current camera. By default, <code>None</code>.</p>"},{"location":"schema/event/","title":"Event","text":""},{"location":"schema/event/#useq.MDAEvent","title":"<code>MDAEvent</code>","text":"<p>Define a single event in a <code>MDASequence</code>.</p> <p>Usually, this object will be generator by iterating over a <code>MDASequence</code> (see <code>useq.MDASequence.iter_events</code>).</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>dict[str, int]</code> <p>Index of this event in the sequence. This is a mapping of axis name to index.  For example: <code>{'t': 4, 'c': 0, 'z': 5},</code></p> <code>channel</code> <code>Channel | None</code> <p>Channel to use for this event. If <code>None</code>, implies use current channel. By default, <code>None</code>.  <code>Channel</code> is a simple pydantic object with two attributes: <code>config</code> and <code>group</code>.  <code>config</code> is the name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).  <code>group</code> is the name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p> <code>exposure</code> <code>PositiveFloat | None</code> <p>Exposure time in seconds. If not provided, implies use current exposure time. By default, <code>None</code>.</p> <code>min_start_time</code> <code>float | None</code> <p>Minimum start time of this event, in seconds.  If provided, the engine will pause until this time has elapsed (relative to the start of the sequence) before starting this event. By default, <code>None</code>.</p> <code>x_pos</code> <code>float | None</code> <p>X position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>y_pos</code> <code>float | None</code> <p>Y position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>z_pos</code> <code>float | None</code> <p>Z position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>properties</code> <code>Sequence[PropertyTuple] | None</code> <p>List of <code>useq.PropertyTuple</code> to set before starting this event. Where each item in the list is a 3-member named tuple of <code>(device_name, property_name, property_value)</code>.  This is inspired by micro-manager's Device Adapter API, but could be used to set arbitrary properties in any backend that supports the concept of devices that have properties with values. By default, <code>None</code>.</p> <code>sequence</code> <code>MDASequence | None</code> <p>A reference to the <code>useq.MDASequence</code> this event belongs to. This is a read-only attribute. By default, <code>None</code>.</p> <code>global_index</code> <code>int</code> <p>The global index of this event in the sequence. For example, in an <code>MDASequence</code> with 2 channels and 5 time points, the global index of each event will be an integer from 0 to 9.  By default, <code>0</code>.</p> <code>metadata</code> <code>dict</code> <p>Optional metadata to be associated with this event.</p>"},{"location":"schema/event/#useq.PropertyTuple","title":"<code>PropertyTuple</code>","text":"<p>Three-tuple capturing a device, property, and value.</p> <p>Attributes:</p> Name Type Description <code>device_name</code> <code>str</code> <p>Name of a device.</p> <code>property_name</code> <code>str</code> <p>Name of a property recognized by the device.</p> <code>value</code> <code>Any</code> <p>Value for the property.</p>"},{"location":"schema/event/#useq._mda_event.Channel","title":"<code>Channel</code>","text":"<p>Channel in a MDA event.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>Name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).</p> <code>group</code> <code>str</code> <p>Optional name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p>"},{"location":"schema/sequence/","title":"Sequence","text":""},{"location":"schema/sequence/#useq.MDASequence","title":"<code>MDASequence</code>","text":"<p>A sequence of MDA (Multi-Dimensional Acquisition) events.</p> <p>This is the core object in the <code>useq</code> library, and is used define a sequence of events to be run on a microscope. It object may be constructed manually, or from file (e.g. json or yaml).</p> <p>The object itself acts as an iterator for <code>useq.MDAEvent</code> objects:</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>dict</code> <p>A dictionary of user metadata to be stored with the sequence.</p> <code>axis_order</code> <code>str</code> <p>The order of the axes in the sequence. Must be a permutation of <code>\"tpcz\"</code>. The default is <code>\"tpcz\"</code>.</p> <code>stage_positions</code> <code>tuple[Position, ...]</code> <p>The stage positions to visit. (each with <code>x</code>, <code>y</code>, <code>z</code>, <code>name</code>, and <code>z_plan</code>, all of which are optional).</p> <code>channels</code> <code>tuple[Channel, ...]</code> <p>The channels to acquire. see <code>Channel</code>.</p> <code>time_plan</code> <code>MultiPhaseTimePlan | TIntervalDuration | TIntervalLoops | TDurationLoops | NoT</code> <p>The time plan to follow. One of <code>TIntervalDuration</code>, <code>TIntervalLoops</code>, <code>TDurationLoops</code>, <code>MultiPhaseTimePlan</code>, or <code>NoT</code></p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | NoZ</code> <p>The z plan to follow. One of <code>ZTopBottom</code>, <code>ZRangeAround</code>, <code>ZAboveBelow</code>, <code>ZRelativePositions</code>, <code>ZAbsolutePositions</code>, or <code>NoZ</code>.</p> <code>uid</code> <code>UUID</code> <p>A read-only unique identifier (uuid version 4) for the sequence. This will be generated, do not set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from useq import MDASequence, Position, Channel, TIntervalDuration\n&gt;&gt;&gt; seq = MDASequence(\n...     time_plan={\"interval\": 0.1, \"loops\": 2},\n...     stage_positions=[(1, 1, 1)],\n...     z_plan={\"range\": 3, \"step\": 1},\n...     channels=[{\"config\": \"DAPI\", \"exposure\": 1}]\n... )\n&gt;&gt;&gt; print(seq)\nMulti-Dimensional Acquisition \u25b6 nt: 2, np: 1, nc: 1, nz: 4\n</code></pre> <pre><code>&gt;&gt;&gt; for event in seq:\n...     print(event)\n</code></pre> <pre><code>&gt;&gt;&gt; print(seq.yaml())\nchannels:\n- config: DAPI\n  exposure: 1.0\nstage_positions:\n- x: 1.0\n  y: 1.0\n  z: 1.0\ntime_plan:\n  interval: '0:00:00.100000'\n  loops: 2\nz_plan:\n  range: 3.0\n  step: 1.0\n</code></pre>"}]}